{
  "version": 3,
  "sources": ["../../camera-controls/dist/camera-controls.module.js", "dep:camera-controls"],
  "sourcesContent": ["/*!\n * camera-controls\n * https://github.com/yomotsu/camera-controls\n * (c) 2017 @yomotsu\n * Released under the MIT License.\n */\nvar ACTION;\r\n(function (ACTION) {\r\n    ACTION[ACTION[\"NONE\"] = 0] = \"NONE\";\r\n    ACTION[ACTION[\"ROTATE\"] = 1] = \"ROTATE\";\r\n    ACTION[ACTION[\"TRUCK\"] = 2] = \"TRUCK\";\r\n    ACTION[ACTION[\"OFFSET\"] = 3] = \"OFFSET\";\r\n    ACTION[ACTION[\"DOLLY\"] = 4] = \"DOLLY\";\r\n    ACTION[ACTION[\"ZOOM\"] = 5] = \"ZOOM\";\r\n    ACTION[ACTION[\"TOUCH_ROTATE\"] = 6] = \"TOUCH_ROTATE\";\r\n    ACTION[ACTION[\"TOUCH_TRUCK\"] = 7] = \"TOUCH_TRUCK\";\r\n    ACTION[ACTION[\"TOUCH_OFFSET\"] = 8] = \"TOUCH_OFFSET\";\r\n    ACTION[ACTION[\"TOUCH_DOLLY\"] = 9] = \"TOUCH_DOLLY\";\r\n    ACTION[ACTION[\"TOUCH_ZOOM\"] = 10] = \"TOUCH_ZOOM\";\r\n    ACTION[ACTION[\"TOUCH_DOLLY_TRUCK\"] = 11] = \"TOUCH_DOLLY_TRUCK\";\r\n    ACTION[ACTION[\"TOUCH_DOLLY_OFFSET\"] = 12] = \"TOUCH_DOLLY_OFFSET\";\r\n    ACTION[ACTION[\"TOUCH_ZOOM_TRUCK\"] = 13] = \"TOUCH_ZOOM_TRUCK\";\r\n    ACTION[ACTION[\"TOUCH_ZOOM_OFFSET\"] = 14] = \"TOUCH_ZOOM_OFFSET\";\r\n})(ACTION || (ACTION = {}));\r\nfunction isPerspectiveCamera(camera) {\r\n    return camera.isPerspectiveCamera;\r\n}\r\nfunction isOrthographicCamera(camera) {\r\n    return camera.isOrthographicCamera;\r\n}\n\nconst PI_2 = Math.PI * 2;\r\nconst PI_HALF = Math.PI / 2;\n\nconst EPSILON = 1e-5;\r\nfunction approxZero(number, error = EPSILON) {\r\n    return Math.abs(number) < error;\r\n}\r\nfunction approxEquals(a, b, error = EPSILON) {\r\n    return approxZero(a - b, error);\r\n}\r\nfunction roundToStep(value, step) {\r\n    return Math.round(value / step) * step;\r\n}\r\nfunction infinityToMaxNumber(value) {\r\n    if (isFinite(value))\r\n        return value;\r\n    if (value < 0)\r\n        return -Number.MAX_VALUE;\r\n    return Number.MAX_VALUE;\r\n}\r\nfunction maxNumberToInfinity(value) {\r\n    if (Math.abs(value) < Number.MAX_VALUE)\r\n        return value;\r\n    return value * Infinity;\r\n}\n\nfunction extractClientCoordFromEvent(pointers, out) {\r\n    out.set(0, 0);\r\n    pointers.forEach((pointer) => {\r\n        out.x += pointer.clientX;\r\n        out.y += pointer.clientY;\r\n    });\r\n    out.x /= pointers.length;\r\n    out.y /= pointers.length;\r\n}\n\nfunction notSupportedInOrthographicCamera(camera, message) {\r\n    if (isOrthographicCamera(camera)) {\r\n        console.warn(`${message} is not supported in OrthographicCamera`);\r\n        return true;\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * A compat function for `Quaternion.invert()` / `Quaternion.inverse()`.\r\n * `Quaternion.invert()` is introduced in r123 and `Quaternion.inverse()` emits a warning.\r\n * We are going to use this compat for a while.\r\n * @param target A target quaternion\r\n */\r\nfunction quatInvertCompat(target) {\r\n    if (target.invert) {\r\n        target.invert();\r\n    }\r\n    else {\r\n        target.inverse();\r\n    }\r\n    return target;\r\n}\n\nclass EventDispatcher {\r\n    constructor() {\r\n        this._listeners = {};\r\n    }\r\n    /**\r\n     * Adds the specified event listener.\r\n     * @param type event name\r\n     * @param listener handler function\r\n     * @category Methods\r\n     */\r\n    addEventListener(type, listener) {\r\n        const listeners = this._listeners;\r\n        if (listeners[type] === undefined)\r\n            listeners[type] = [];\r\n        if (listeners[type].indexOf(listener) === -1)\r\n            listeners[type].push(listener);\r\n    }\r\n    // hasEventListener( type: string, listener: Listener ): boolean {\r\n    // \tconst listeners = this._listeners;\r\n    // \treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\r\n    // }\r\n    /**\r\n     * Removes the specified event listener\r\n     * @param type event name\r\n     * @param listener handler function\r\n     * @category Methods\r\n     */\r\n    removeEventListener(type, listener) {\r\n        const listeners = this._listeners;\r\n        const listenerArray = listeners[type];\r\n        if (listenerArray !== undefined) {\r\n            const index = listenerArray.indexOf(listener);\r\n            if (index !== -1)\r\n                listenerArray.splice(index, 1);\r\n        }\r\n    }\r\n    /**\r\n     * Removes all event listeners\r\n     * @param type event name\r\n     * @category Methods\r\n     */\r\n    removeAllEventListeners(type) {\r\n        if (!type) {\r\n            this._listeners = {};\r\n            return;\r\n        }\r\n        if (Array.isArray(this._listeners[type]))\r\n            this._listeners[type].length = 0;\r\n    }\r\n    /**\r\n     * Fire an event type.\r\n     * @param event DispatcherEvent\r\n     * @category Methods\r\n     */\r\n    dispatchEvent(event) {\r\n        const listeners = this._listeners;\r\n        const listenerArray = listeners[event.type];\r\n        if (listenerArray !== undefined) {\r\n            event.target = this;\r\n            const array = listenerArray.slice(0);\r\n            for (let i = 0, l = array.length; i < l; i++) {\r\n                array[i].call(this, event);\r\n            }\r\n        }\r\n    }\r\n}\n\nconst isBrowser = typeof window !== 'undefined';\r\nconst isMac = isBrowser && /Mac/.test(navigator.platform);\r\nconst isPointerEventsNotSupported = !(isBrowser && 'PointerEvent' in window); // Safari 12 does not support PointerEvents API\r\nconst readonlyACTION = Object.freeze(ACTION);\r\nconst TOUCH_DOLLY_FACTOR = 1 / 8;\r\nlet THREE;\r\nlet _ORIGIN;\r\nlet _AXIS_Y;\r\nlet _AXIS_Z;\r\nlet _v2;\r\nlet _v3A;\r\nlet _v3B;\r\nlet _v3C;\r\nlet _xColumn;\r\nlet _yColumn;\r\nlet _zColumn;\r\nlet _deltaTarget;\r\nlet _deltaOffset;\r\nlet _sphericalA;\r\nlet _sphericalB;\r\nlet _box3A;\r\nlet _box3B;\r\nlet _sphere;\r\nlet _quaternionA;\r\nlet _quaternionB;\r\nlet _rotationMatrix;\r\nlet _raycaster;\r\nclass CameraControls extends EventDispatcher {\r\n    /**\r\n     * Creates a `CameraControls` instance.\r\n     *\r\n     * Note:\r\n     * You **must install** three.js before using camera-controls. see [#install](#install)\r\n     * Not doing so will lead to runtime errors (`undefined` references to THREE).\r\n     *\r\n     * e.g.\r\n     * ```\r\n     * CameraControls.install( { THREE } );\r\n     * const cameraControls = new CameraControls( camera, domElement );\r\n     * ```\r\n     *\r\n     * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.\r\n     * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.\r\n     * @category Constructor\r\n     */\r\n    constructor(camera, domElement) {\r\n        super();\r\n        /**\r\n         * Minimum vertical angle in radians.\r\n         * The angle has to be between `0` and `.maxPolarAngle` inclusive.\r\n         * The default value is `0`.\r\n         *\r\n         * e.g.\r\n         * ```\r\n         * cameraControls.maxPolarAngle = 0;\r\n         * ```\r\n         * @category Properties\r\n         */\r\n        this.minPolarAngle = 0; // radians\r\n        /**\r\n         * Maximum vertical angle in radians.\r\n         * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.\r\n         * The default value is `Math.PI`.\r\n         *\r\n         * e.g.\r\n         * ```\r\n         * cameraControls.maxPolarAngle = Math.PI;\r\n         * ```\r\n         * @category Properties\r\n         */\r\n        this.maxPolarAngle = Math.PI; // radians\r\n        /**\r\n         * Minimum horizontal angle in radians.\r\n         * The angle has to be less than `.maxAzimuthAngle`.\r\n         * The default value is `- Infinity`.\r\n         *\r\n         * e.g.\r\n         * ```\r\n         * cameraControls.minAzimuthAngle = - Infinity;\r\n         * ```\r\n         * @category Properties\r\n         */\r\n        this.minAzimuthAngle = -Infinity; // radians\r\n        /**\r\n         * Maximum horizontal angle in radians.\r\n         * The angle has to be greater than `.minAzimuthAngle`.\r\n         * The default value is `Infinity`.\r\n         *\r\n         * e.g.\r\n         * ```\r\n         * cameraControls.maxAzimuthAngle = Infinity;\r\n         * ```\r\n         * @category Properties\r\n         */\r\n        this.maxAzimuthAngle = Infinity; // radians\r\n        // How far you can dolly in and out ( PerspectiveCamera only )\r\n        /**\r\n         * Minimum distance for dolly. The value must be higher than `0`.\r\n         * PerspectiveCamera only.\r\n         * @category Properties\r\n         */\r\n        this.minDistance = 0;\r\n        /**\r\n         * Maximum distance for dolly. The value must be higher than `minDistance`.\r\n         * PerspectiveCamera only.\r\n         * @category Properties\r\n         */\r\n        this.maxDistance = Infinity;\r\n        /**\r\n         * `true` to enable Infinity Dolly.\r\n         * When the Dolly distance is less than the `minDistance`, radius of the sphere will be set `minDistance` automatically.\r\n         * @category Properties\r\n         */\r\n        this.infinityDolly = false;\r\n        /**\r\n         * Minimum camera zoom.\r\n         * @category Properties\r\n         */\r\n        this.minZoom = 0.01;\r\n        /**\r\n         * Maximum camera zoom.\r\n         * @category Properties\r\n         */\r\n        this.maxZoom = Infinity;\r\n        /**\r\n         * The damping inertia.\r\n         * The value must be between `Math.EPSILON` to `1` inclusive.\r\n         * Setting `1` to disable smooth transitions.\r\n         * @category Properties\r\n         */\r\n        this.dampingFactor = 0.05;\r\n        /**\r\n         * The damping inertia while dragging.\r\n         * The value must be between `Math.EPSILON` to `1` inclusive.\r\n         * Setting `1` to disable smooth transitions.\r\n         * @category Properties\r\n         */\r\n        this.draggingDampingFactor = 0.25;\r\n        /**\r\n         * Speed of azimuth (horizontal) rotation.\r\n         * @category Properties\r\n         */\r\n        this.azimuthRotateSpeed = 1.0;\r\n        /**\r\n         * Speed of polar (vertical) rotation.\r\n         * @category Properties\r\n         */\r\n        this.polarRotateSpeed = 1.0;\r\n        /**\r\n         * Speed of mouse-wheel dollying.\r\n         * @category Properties\r\n         */\r\n        this.dollySpeed = 1.0;\r\n        /**\r\n         * Speed of drag for truck and pedestal.\r\n         * @category Properties\r\n         */\r\n        this.truckSpeed = 2.0;\r\n        /**\r\n         * `true` to enable Dolly-in to the mouse cursor coords.\r\n         * @category Properties\r\n         */\r\n        this.dollyToCursor = false;\r\n        /**\r\n         * @category Properties\r\n         */\r\n        this.dragToOffset = false;\r\n        /**\r\n         * The same as `.screenSpacePanning` in three.js's OrbitControls.\r\n         * @category Properties\r\n         */\r\n        this.verticalDragToForward = false;\r\n        /**\r\n         * Friction ratio of the boundary.\r\n         * @category Properties\r\n         */\r\n        this.boundaryFriction = 0.0;\r\n        /**\r\n         * Controls how soon the `rest` event fires as the camera slows.\r\n         * @category Properties\r\n         */\r\n        this.restThreshold = 0.01;\r\n        /**\r\n         * An array of Meshes to collide with camera.\r\n         * Be aware colliderMeshes may decrease performance. The collision test uses 4 raycasters from the camera since the near plane has 4 corners.\r\n         * @category Properties\r\n         */\r\n        this.colliderMeshes = [];\r\n        /**\r\n         * Force cancel user dragging.\r\n         * @category Methods\r\n         */\r\n        // cancel will be overwritten in the constructor.\r\n        this.cancel = () => { };\r\n        this._enabled = true;\r\n        this._state = ACTION.NONE;\r\n        this._viewport = null;\r\n        this._dollyControlAmount = 0;\r\n        this._hasRested = true;\r\n        this._boundaryEnclosesCamera = false;\r\n        this._needsUpdate = true;\r\n        this._updatedLastTime = false;\r\n        this._elementRect = new DOMRect();\r\n        this._activePointers = [];\r\n        this._truckInternal = (deltaX, deltaY, dragToOffset) => {\r\n            if (isPerspectiveCamera(this._camera)) {\r\n                const offset = _v3A.copy(this._camera.position).sub(this._target);\r\n                // half of the fov is center to top of screen\r\n                const fov = this._camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD;\r\n                const targetDistance = offset.length() * Math.tan(fov * 0.5);\r\n                const truckX = (this.truckSpeed * deltaX * targetDistance / this._elementRect.height);\r\n                const pedestalY = (this.truckSpeed * deltaY * targetDistance / this._elementRect.height);\r\n                if (this.verticalDragToForward) {\r\n                    dragToOffset ?\r\n                        this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) :\r\n                        this.truck(truckX, 0, true);\r\n                    this.forward(-pedestalY, true);\r\n                }\r\n                else {\r\n                    dragToOffset ?\r\n                        this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) :\r\n                        this.truck(truckX, pedestalY, true);\r\n                }\r\n            }\r\n            else if (isOrthographicCamera(this._camera)) {\r\n                // orthographic\r\n                const camera = this._camera;\r\n                const truckX = deltaX * (camera.right - camera.left) / camera.zoom / this._elementRect.width;\r\n                const pedestalY = deltaY * (camera.top - camera.bottom) / camera.zoom / this._elementRect.height;\r\n                dragToOffset ?\r\n                    this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) :\r\n                    this.truck(truckX, pedestalY, true);\r\n            }\r\n        };\r\n        this._rotateInternal = (deltaX, deltaY) => {\r\n            const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height; // divide by *height* to refer the resolution\r\n            const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;\r\n            this.rotate(theta, phi, true);\r\n        };\r\n        this._dollyInternal = (delta, x, y) => {\r\n            const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);\r\n            const distance = this._sphericalEnd.radius * dollyScale;\r\n            const prevRadius = this._sphericalEnd.radius;\r\n            const signedPrevRadius = prevRadius * (delta >= 0 ? -1 : 1);\r\n            this.dollyTo(distance);\r\n            if (this.infinityDolly && (distance < this.minDistance || this.maxDistance === this.minDistance)) {\r\n                this._camera.getWorldDirection(_v3A);\r\n                this._targetEnd.add(_v3A.normalize().multiplyScalar(signedPrevRadius));\r\n                this._target.add(_v3A.normalize().multiplyScalar(signedPrevRadius));\r\n            }\r\n            if (this.dollyToCursor) {\r\n                this._dollyControlAmount += this._sphericalEnd.radius - prevRadius;\r\n                if (this.infinityDolly && (distance < this.minDistance || this.maxDistance === this.minDistance)) {\r\n                    this._dollyControlAmount -= signedPrevRadius;\r\n                }\r\n                this._dollyControlCoord.set(x, y);\r\n            }\r\n            return;\r\n        };\r\n        this._zoomInternal = (delta, x, y) => {\r\n            const zoomScale = Math.pow(0.95, delta * this.dollySpeed);\r\n            // for both PerspectiveCamera and OrthographicCamera\r\n            this.zoomTo(this._zoom * zoomScale);\r\n            if (this.dollyToCursor) {\r\n                this._dollyControlAmount = this._zoomEnd;\r\n                this._dollyControlCoord.set(x, y);\r\n            }\r\n            return;\r\n        };\r\n        // Check if the user has installed THREE\r\n        if (typeof THREE === 'undefined') {\r\n            console.error('camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.');\r\n        }\r\n        this._camera = camera;\r\n        this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);\r\n        this._yAxisUpSpaceInverse = quatInvertCompat(this._yAxisUpSpace.clone());\r\n        this._state = ACTION.NONE;\r\n        this._domElement = domElement;\r\n        this._domElement.style.touchAction = 'none';\r\n        this._domElement.style.userSelect = 'none';\r\n        this._domElement.style.webkitUserSelect = 'none';\r\n        // the location\r\n        this._target = new THREE.Vector3();\r\n        this._targetEnd = this._target.clone();\r\n        this._focalOffset = new THREE.Vector3();\r\n        this._focalOffsetEnd = this._focalOffset.clone();\r\n        // rotation\r\n        this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));\r\n        this._sphericalEnd = this._spherical.clone();\r\n        this._zoom = this._camera.zoom;\r\n        this._zoomEnd = this._zoom;\r\n        // collisionTest uses nearPlane.s\r\n        this._nearPlaneCorners = [\r\n            new THREE.Vector3(),\r\n            new THREE.Vector3(),\r\n            new THREE.Vector3(),\r\n            new THREE.Vector3(),\r\n        ];\r\n        this._updateNearPlaneCorners();\r\n        // Target cannot move outside of this box\r\n        this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));\r\n        // reset\r\n        this._target0 = this._target.clone();\r\n        this._position0 = this._camera.position.clone();\r\n        this._zoom0 = this._zoom;\r\n        this._focalOffset0 = this._focalOffset.clone();\r\n        this._dollyControlAmount = 0;\r\n        this._dollyControlCoord = new THREE.Vector2();\r\n        // configs\r\n        this.mouseButtons = {\r\n            left: ACTION.ROTATE,\r\n            middle: ACTION.DOLLY,\r\n            right: ACTION.TRUCK,\r\n            wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY :\r\n                isOrthographicCamera(this._camera) ? ACTION.ZOOM :\r\n                    ACTION.NONE,\r\n            shiftLeft: ACTION.NONE,\r\n            // We can also add altLeft and etc if someone wants...\r\n        };\r\n        this.touches = {\r\n            one: ACTION.TOUCH_ROTATE,\r\n            two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK :\r\n                isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK :\r\n                    ACTION.NONE,\r\n            three: ACTION.TOUCH_TRUCK,\r\n        };\r\n        if (this._domElement) {\r\n            const dragStartPosition = new THREE.Vector2();\r\n            const lastDragPosition = new THREE.Vector2();\r\n            const dollyStart = new THREE.Vector2();\r\n            const onPointerDown = (event) => {\r\n                if (!this._enabled)\r\n                    return;\r\n                // Don't call `event.preventDefault()` on the pointerdown event\r\n                // to keep receiving pointermove evens outside dragging iframe\r\n                // https://taye.me/blog/tips/2015/11/16/mouse-drag-outside-iframe/\r\n                const pointer = {\r\n                    pointerId: event.pointerId,\r\n                    clientX: event.clientX,\r\n                    clientY: event.clientY,\r\n                };\r\n                this._activePointers.push(pointer);\r\n                switch (event.button) {\r\n                    case THREE.MOUSE.LEFT:\r\n                        this._state = event.shiftKey ? this.mouseButtons.shiftLeft : this.mouseButtons.left;\r\n                        break;\r\n                    case THREE.MOUSE.MIDDLE:\r\n                        this._state = this.mouseButtons.middle;\r\n                        break;\r\n                    case THREE.MOUSE.RIGHT:\r\n                        this._state = this.mouseButtons.right;\r\n                        break;\r\n                }\r\n                if (event.pointerType === 'touch') {\r\n                    switch (this._activePointers.length) {\r\n                        case 1:\r\n                            this._state = this.touches.one;\r\n                            break;\r\n                        case 2:\r\n                            this._state = this.touches.two;\r\n                            break;\r\n                        case 3:\r\n                            this._state = this.touches.three;\r\n                            break;\r\n                    }\r\n                }\r\n                // eslint-disable-next-line no-undef\r\n                this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\r\n                this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\r\n                this._domElement.ownerDocument.addEventListener('pointermove', onPointerMove, { passive: false });\r\n                this._domElement.ownerDocument.addEventListener('pointerup', onPointerUp);\r\n                startDragging();\r\n            };\r\n            const onMouseDown = (event) => {\r\n                if (!this._enabled)\r\n                    return;\r\n                const pointer = {\r\n                    pointerId: 0,\r\n                    clientX: event.clientX,\r\n                    clientY: event.clientY,\r\n                };\r\n                this._activePointers.push(pointer);\r\n                switch (event.button) {\r\n                    case THREE.MOUSE.LEFT:\r\n                        this._state = event.shiftKey ? this.mouseButtons.shiftLeft : this.mouseButtons.left;\r\n                        break;\r\n                    case THREE.MOUSE.MIDDLE:\r\n                        this._state = this.mouseButtons.middle;\r\n                        break;\r\n                    case THREE.MOUSE.RIGHT:\r\n                        this._state = this.mouseButtons.right;\r\n                        break;\r\n                }\r\n                // see https://github.com/microsoft/TypeScript/issues/32912#issuecomment-522142969\r\n                // eslint-disable-next-line no-undef\r\n                this._domElement.ownerDocument.removeEventListener('mousemove', onMouseMove);\r\n                this._domElement.ownerDocument.removeEventListener('mouseup', onMouseUp);\r\n                this._domElement.ownerDocument.addEventListener('mousemove', onMouseMove);\r\n                this._domElement.ownerDocument.addEventListener('mouseup', onMouseUp);\r\n                startDragging();\r\n            };\r\n            const onTouchStart = (event) => {\r\n                if (!this._enabled)\r\n                    return;\r\n                event.preventDefault();\r\n                Array.prototype.forEach.call(event.changedTouches, (touch) => {\r\n                    const pointer = {\r\n                        pointerId: touch.identifier,\r\n                        clientX: touch.clientX,\r\n                        clientY: touch.clientY,\r\n                    };\r\n                    this._activePointers.push(pointer);\r\n                });\r\n                switch (this._activePointers.length) {\r\n                    case 1:\r\n                        this._state = this.touches.one;\r\n                        break;\r\n                    case 2:\r\n                        this._state = this.touches.two;\r\n                        break;\r\n                    case 3:\r\n                        this._state = this.touches.three;\r\n                        break;\r\n                }\r\n                // eslint-disable-next-line no-undef\r\n                this._domElement.ownerDocument.removeEventListener('touchmove', onTouchMove, { passive: false });\r\n                this._domElement.ownerDocument.removeEventListener('touchend', onTouchEnd);\r\n                this._domElement.ownerDocument.addEventListener('touchmove', onTouchMove, { passive: false });\r\n                this._domElement.ownerDocument.addEventListener('touchend', onTouchEnd);\r\n                startDragging();\r\n            };\r\n            const onPointerMove = (event) => {\r\n                if (event.cancelable)\r\n                    event.preventDefault();\r\n                const pointerId = event.pointerId;\r\n                const pointer = this._findPointerById(pointerId);\r\n                if (!pointer)\r\n                    return;\r\n                pointer.clientX = event.clientX;\r\n                pointer.clientY = event.clientY;\r\n                dragging();\r\n            };\r\n            const onMouseMove = (event) => {\r\n                const pointer = this._findPointerById(0);\r\n                if (!pointer)\r\n                    return;\r\n                pointer.clientX = event.clientX;\r\n                pointer.clientY = event.clientY;\r\n                dragging();\r\n            };\r\n            const onTouchMove = (event) => {\r\n                if (event.cancelable)\r\n                    event.preventDefault();\r\n                Array.prototype.forEach.call(event.changedTouches, (touch) => {\r\n                    const pointerId = touch.identifier;\r\n                    const pointer = this._findPointerById(pointerId);\r\n                    if (!pointer)\r\n                        return;\r\n                    pointer.clientX = touch.clientX;\r\n                    pointer.clientY = touch.clientY;\r\n                });\r\n                dragging();\r\n            };\r\n            const onPointerUp = (event) => {\r\n                const pointerId = event.pointerId;\r\n                const pointer = this._findPointerById(pointerId);\r\n                pointer && this._activePointers.splice(this._activePointers.indexOf(pointer), 1);\r\n                if (event.pointerType === 'touch') {\r\n                    switch (this._activePointers.length) {\r\n                        case 0:\r\n                            this._state = ACTION.NONE;\r\n                            break;\r\n                        case 1:\r\n                            this._state = this.touches.one;\r\n                            break;\r\n                        case 2:\r\n                            this._state = this.touches.two;\r\n                            break;\r\n                        case 3:\r\n                            this._state = this.touches.three;\r\n                            break;\r\n                    }\r\n                }\r\n                else {\r\n                    this._state = ACTION.NONE;\r\n                }\r\n                endDragging();\r\n            };\r\n            const onMouseUp = () => {\r\n                const pointer = this._findPointerById(0);\r\n                pointer && this._activePointers.splice(this._activePointers.indexOf(pointer), 1);\r\n                this._state = ACTION.NONE;\r\n                endDragging();\r\n            };\r\n            const onTouchEnd = (event) => {\r\n                Array.prototype.forEach.call(event.changedTouches, (touch) => {\r\n                    const pointerId = touch.identifier;\r\n                    const pointer = this._findPointerById(pointerId);\r\n                    pointer && this._activePointers.splice(this._activePointers.indexOf(pointer), 1);\r\n                });\r\n                switch (this._activePointers.length) {\r\n                    case 0:\r\n                        this._state = ACTION.NONE;\r\n                        break;\r\n                    case 1:\r\n                        this._state = this.touches.one;\r\n                        break;\r\n                    case 2:\r\n                        this._state = this.touches.two;\r\n                        break;\r\n                    case 3:\r\n                        this._state = this.touches.three;\r\n                        break;\r\n                }\r\n                endDragging();\r\n            };\r\n            let lastScrollTimeStamp = -1;\r\n            const onMouseWheel = (event) => {\r\n                if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)\r\n                    return;\r\n                event.preventDefault();\r\n                if (this.dollyToCursor ||\r\n                    this.mouseButtons.wheel === ACTION.ROTATE ||\r\n                    this.mouseButtons.wheel === ACTION.TRUCK) {\r\n                    const now = performance.now();\r\n                    // only need to fire this at scroll start.\r\n                    if (lastScrollTimeStamp - now < 1000)\r\n                        this._getClientRect(this._elementRect);\r\n                    lastScrollTimeStamp = now;\r\n                }\r\n                // Ref: https://github.com/cedricpinson/osgjs/blob/00e5a7e9d9206c06fdde0436e1d62ab7cb5ce853/sources/osgViewer/input/source/InputSourceMouse.js#L89-L103\r\n                const deltaYFactor = isMac ? -1 : -3;\r\n                const delta = (event.deltaMode === 1) ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);\r\n                const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;\r\n                const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;\r\n                switch (this.mouseButtons.wheel) {\r\n                    case ACTION.ROTATE: {\r\n                        this._rotateInternal(event.deltaX, event.deltaY);\r\n                        break;\r\n                    }\r\n                    case ACTION.TRUCK: {\r\n                        this._truckInternal(event.deltaX, event.deltaY, false);\r\n                        break;\r\n                    }\r\n                    case ACTION.OFFSET: {\r\n                        this._truckInternal(event.deltaX, event.deltaY, true);\r\n                        break;\r\n                    }\r\n                    case ACTION.DOLLY: {\r\n                        this._dollyInternal(-delta, x, y);\r\n                        break;\r\n                    }\r\n                    case ACTION.ZOOM: {\r\n                        this._zoomInternal(-delta, x, y);\r\n                        break;\r\n                    }\r\n                }\r\n                this.dispatchEvent({ type: 'control' });\r\n            };\r\n            const onContextMenu = (event) => {\r\n                if (!this._enabled)\r\n                    return;\r\n                event.preventDefault();\r\n            };\r\n            const startDragging = () => {\r\n                if (!this._enabled)\r\n                    return;\r\n                extractClientCoordFromEvent(this._activePointers, _v2);\r\n                this._getClientRect(this._elementRect);\r\n                dragStartPosition.copy(_v2);\r\n                lastDragPosition.copy(_v2);\r\n                const isMultiTouch = this._activePointers.length >= 2;\r\n                if (isMultiTouch) {\r\n                    // 2 finger pinch\r\n                    const dx = _v2.x - this._activePointers[1].clientX;\r\n                    const dy = _v2.y - this._activePointers[1].clientY;\r\n                    const distance = Math.sqrt(dx * dx + dy * dy);\r\n                    dollyStart.set(0, distance);\r\n                    // center coords of 2 finger truck\r\n                    const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;\r\n                    const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;\r\n                    lastDragPosition.set(x, y);\r\n                }\r\n                this.dispatchEvent({ type: 'controlstart' });\r\n            };\r\n            const dragging = () => {\r\n                if (!this._enabled)\r\n                    return;\r\n                extractClientCoordFromEvent(this._activePointers, _v2);\r\n                const deltaX = lastDragPosition.x - _v2.x;\r\n                const deltaY = lastDragPosition.y - _v2.y;\r\n                lastDragPosition.copy(_v2);\r\n                switch (this._state) {\r\n                    case ACTION.ROTATE:\r\n                    case ACTION.TOUCH_ROTATE: {\r\n                        this._rotateInternal(deltaX, deltaY);\r\n                        break;\r\n                    }\r\n                    case ACTION.DOLLY:\r\n                    case ACTION.ZOOM: {\r\n                        const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;\r\n                        const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;\r\n                        this._state === ACTION.DOLLY ?\r\n                            this._dollyInternal(deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY) :\r\n                            this._zoomInternal(deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);\r\n                        break;\r\n                    }\r\n                    case ACTION.TOUCH_DOLLY:\r\n                    case ACTION.TOUCH_ZOOM:\r\n                    case ACTION.TOUCH_DOLLY_TRUCK:\r\n                    case ACTION.TOUCH_ZOOM_TRUCK:\r\n                    case ACTION.TOUCH_DOLLY_OFFSET:\r\n                    case ACTION.TOUCH_ZOOM_OFFSET: {\r\n                        const dx = _v2.x - this._activePointers[1].clientX;\r\n                        const dy = _v2.y - this._activePointers[1].clientY;\r\n                        const distance = Math.sqrt(dx * dx + dy * dy);\r\n                        const dollyDelta = dollyStart.y - distance;\r\n                        dollyStart.set(0, distance);\r\n                        const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;\r\n                        const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;\r\n                        this._state === ACTION.TOUCH_DOLLY ||\r\n                            this._state === ACTION.TOUCH_DOLLY_TRUCK ||\r\n                            this._state === ACTION.TOUCH_DOLLY_OFFSET ?\r\n                            this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY) :\r\n                            this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);\r\n                        if (this._state === ACTION.TOUCH_DOLLY_TRUCK ||\r\n                            this._state === ACTION.TOUCH_ZOOM_TRUCK) {\r\n                            this._truckInternal(deltaX, deltaY, false);\r\n                        }\r\n                        else if (this._state === ACTION.TOUCH_DOLLY_OFFSET ||\r\n                            this._state === ACTION.TOUCH_ZOOM_OFFSET) {\r\n                            this._truckInternal(deltaX, deltaY, true);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case ACTION.TRUCK:\r\n                    case ACTION.TOUCH_TRUCK: {\r\n                        this._truckInternal(deltaX, deltaY, false);\r\n                        break;\r\n                    }\r\n                    case ACTION.OFFSET:\r\n                    case ACTION.TOUCH_OFFSET: {\r\n                        this._truckInternal(deltaX, deltaY, true);\r\n                        break;\r\n                    }\r\n                }\r\n                this.dispatchEvent({ type: 'control' });\r\n            };\r\n            const endDragging = () => {\r\n                extractClientCoordFromEvent(this._activePointers, _v2);\r\n                lastDragPosition.copy(_v2);\r\n                if (this._activePointers.length === 0) {\r\n                    // eslint-disable-next-line no-undef\r\n                    this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\r\n                    this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\r\n                    // eslint-disable-next-line no-undef\r\n                    this._domElement.ownerDocument.removeEventListener('touchmove', onTouchMove, { passive: false });\r\n                    this._domElement.ownerDocument.removeEventListener('touchend', onTouchEnd);\r\n                    this.dispatchEvent({ type: 'controlend' });\r\n                }\r\n            };\r\n            this._domElement.addEventListener('pointerdown', onPointerDown);\r\n            isPointerEventsNotSupported && this._domElement.addEventListener('mousedown', onMouseDown);\r\n            isPointerEventsNotSupported && this._domElement.addEventListener('touchstart', onTouchStart);\r\n            this._domElement.addEventListener('pointercancel', onPointerUp);\r\n            this._domElement.addEventListener('wheel', onMouseWheel, { passive: false });\r\n            this._domElement.addEventListener('contextmenu', onContextMenu);\r\n            this._removeAllEventListeners = () => {\r\n                this._domElement.removeEventListener('pointerdown', onPointerDown);\r\n                this._domElement.removeEventListener('mousedown', onMouseDown);\r\n                this._domElement.removeEventListener('touchstart', onTouchStart);\r\n                this._domElement.removeEventListener('pointercancel', onPointerUp);\r\n                // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener#matching_event_listeners_for_removal\r\n                // > it's probably wise to use the same values used for the call to `addEventListener()` when calling `removeEventListener()`\r\n                // see https://github.com/microsoft/TypeScript/issues/32912#issuecomment-522142969\r\n                // eslint-disable-next-line no-undef\r\n                this._domElement.removeEventListener('wheel', onMouseWheel, { passive: false });\r\n                this._domElement.removeEventListener('contextmenu', onContextMenu);\r\n                // eslint-disable-next-line no-undef\r\n                this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\r\n                this._domElement.ownerDocument.removeEventListener('mousemove', onMouseMove);\r\n                // eslint-disable-next-line no-undef\r\n                this._domElement.ownerDocument.removeEventListener('touchmove', onTouchMove, { passive: false });\r\n                this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\r\n                this._domElement.ownerDocument.removeEventListener('mouseup', onMouseUp);\r\n                this._domElement.ownerDocument.removeEventListener('touchend', onTouchEnd);\r\n            };\r\n            this.cancel = () => {\r\n                if (this._state === ACTION.NONE)\r\n                    return;\r\n                this._state = ACTION.NONE;\r\n                this._activePointers.length = 0;\r\n                endDragging();\r\n            };\r\n        }\r\n        this.update(0);\r\n    }\r\n    /**\r\n     * Injects THREE as the dependency. You can then proceed to use CameraControls.\r\n     *\r\n     * e.g\r\n     * ```javascript\r\n     * CameraControls.install( { THREE: THREE } );\r\n     * ```\r\n     *\r\n     * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.\r\n     *\r\n     * ```js\r\n     * import {\r\n     * \tMOUSE,\r\n     * \tVector2,\r\n     * \tVector3,\r\n     * \tVector4,\r\n     * \tQuaternion,\r\n     * \tMatrix4,\r\n     * \tSpherical,\r\n     * \tBox3,\r\n     * \tSphere,\r\n     * \tRaycaster,\r\n     * \tMathUtils,\r\n     * } from 'three';\r\n     *\r\n     * const subsetOfTHREE = {\r\n     * \tMOUSE     : MOUSE,\r\n     * \tVector2   : Vector2,\r\n     * \tVector3   : Vector3,\r\n     * \tVector4   : Vector4,\r\n     * \tQuaternion: Quaternion,\r\n     * \tMatrix4   : Matrix4,\r\n     * \tSpherical : Spherical,\r\n     * \tBox3      : Box3,\r\n     * \tSphere    : Sphere,\r\n     * \tRaycaster : Raycaster,\r\n     * \tMathUtils : {\r\n     * \t\tDEG2RAD: MathUtils.DEG2RAD,\r\n     * \t\tclamp: MathUtils.clamp,\r\n     * \t},\r\n     * };\r\n\n     * CameraControls.install( { THREE: subsetOfTHREE } );\r\n     * ```\r\n     * @category Statics\r\n     */\r\n    static install(libs) {\r\n        THREE = libs.THREE;\r\n        _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));\r\n        _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));\r\n        _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));\r\n        _v2 = new THREE.Vector2();\r\n        _v3A = new THREE.Vector3();\r\n        _v3B = new THREE.Vector3();\r\n        _v3C = new THREE.Vector3();\r\n        _xColumn = new THREE.Vector3();\r\n        _yColumn = new THREE.Vector3();\r\n        _zColumn = new THREE.Vector3();\r\n        _deltaTarget = new THREE.Vector3();\r\n        _deltaOffset = new THREE.Vector3();\r\n        _sphericalA = new THREE.Spherical();\r\n        _sphericalB = new THREE.Spherical();\r\n        _box3A = new THREE.Box3();\r\n        _box3B = new THREE.Box3();\r\n        _sphere = new THREE.Sphere();\r\n        _quaternionA = new THREE.Quaternion();\r\n        _quaternionB = new THREE.Quaternion();\r\n        _rotationMatrix = new THREE.Matrix4();\r\n        _raycaster = new THREE.Raycaster();\r\n    }\r\n    /**\r\n     * list all ACTIONs\r\n     * @category Statics\r\n     */\r\n    static get ACTION() {\r\n        return readonlyACTION;\r\n    }\r\n    /**\r\n     * The camera to be controlled\r\n     * @category Properties\r\n     */\r\n    get camera() {\r\n        return this._camera;\r\n    }\r\n    set camera(camera) {\r\n        this._camera = camera;\r\n        this.updateCameraUp();\r\n        this._camera.updateProjectionMatrix();\r\n        this._updateNearPlaneCorners();\r\n        this._needsUpdate = true;\r\n    }\r\n    /**\r\n     * Whether or not the controls are enabled.\r\n     * `false` to disable user dragging/touch-move, but all methods works.\r\n     * @category Properties\r\n     */\r\n    get enabled() {\r\n        return this._enabled;\r\n    }\r\n    set enabled(enabled) {\r\n        this._enabled = enabled;\r\n        if (enabled) {\r\n            this._domElement.style.touchAction = 'none';\r\n            this._domElement.style.userSelect = 'none';\r\n            this._domElement.style.webkitUserSelect = 'none';\r\n        }\r\n        else {\r\n            this.cancel();\r\n            this._domElement.style.touchAction = '';\r\n            this._domElement.style.userSelect = '';\r\n            this._domElement.style.webkitUserSelect = '';\r\n        }\r\n    }\r\n    /**\r\n     * Returns `true` if the controls are active updating.\r\n     * readonly value.\r\n     * @category Properties\r\n     */\r\n    get active() {\r\n        return !this._hasRested;\r\n    }\r\n    /**\r\n     * Getter for the current `ACTION`.\r\n     * readonly value.\r\n     * @category Properties\r\n     */\r\n    get currentAction() {\r\n        return this._state;\r\n    }\r\n    /**\r\n     * get/set Current distance.\r\n     * @category Properties\r\n     */\r\n    get distance() {\r\n        return this._spherical.radius;\r\n    }\r\n    set distance(distance) {\r\n        if (this._spherical.radius === distance &&\r\n            this._sphericalEnd.radius === distance)\r\n            return;\r\n        this._spherical.radius = distance;\r\n        this._sphericalEnd.radius = distance;\r\n        this._needsUpdate = true;\r\n    }\r\n    // horizontal angle\r\n    /**\r\n     * get/set the azimuth angle (horizontal) in radians.\r\n     * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.\r\n     * @category Properties\r\n     */\r\n    get azimuthAngle() {\r\n        return this._spherical.theta;\r\n    }\r\n    set azimuthAngle(azimuthAngle) {\r\n        if (this._spherical.theta === azimuthAngle &&\r\n            this._sphericalEnd.theta === azimuthAngle)\r\n            return;\r\n        this._spherical.theta = azimuthAngle;\r\n        this._sphericalEnd.theta = azimuthAngle;\r\n        this._needsUpdate = true;\r\n    }\r\n    // vertical angle\r\n    /**\r\n     * get/set the polar angle (vertical) in radians.\r\n     * @category Properties\r\n     */\r\n    get polarAngle() {\r\n        return this._spherical.phi;\r\n    }\r\n    set polarAngle(polarAngle) {\r\n        if (this._spherical.phi === polarAngle &&\r\n            this._sphericalEnd.phi === polarAngle)\r\n            return;\r\n        this._spherical.phi = polarAngle;\r\n        this._sphericalEnd.phi = polarAngle;\r\n        this._needsUpdate = true;\r\n    }\r\n    /**\r\n     * Whether camera position should be enclosed in the boundary or not.\r\n     * @category Properties\r\n     */\r\n    get boundaryEnclosesCamera() {\r\n        return this._boundaryEnclosesCamera;\r\n    }\r\n    set boundaryEnclosesCamera(boundaryEnclosesCamera) {\r\n        this._boundaryEnclosesCamera = boundaryEnclosesCamera;\r\n        this._needsUpdate = true;\r\n    }\r\n    /**\r\n     * Adds the specified event listener.\r\n     * Applicable event types (which is `K`) are:\r\n     * | Event name          | Timing |\r\n     * | ------------------- | ------ |\r\n     * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. \u00B9 |\r\n     * | `'control'`         | When the user controls the camera (dragging). |\r\n     * | `'controlend'`      | When the user ends to control the camera. \u00B9 |\r\n     * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |\r\n     * | `'update'`          | When the camera position is updated. |\r\n     * | `'wake'`            | When the camera starts moving. |\r\n     * | `'rest'`            | When the camera movement is below `.restThreshold` \u00B2. |\r\n     * | `'sleep'`           | When the camera end moving. |\r\n     *\r\n     * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means \"start\" and \"end\" cannot be detected.\r\n     * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).\r\n     *\r\n     * e.g.\r\n     * ```\r\n     * cameraControl.addEventListener( 'controlstart', myCallbackFunction );\r\n     * ```\r\n     * @param type event name\r\n     * @param listener handler function\r\n     * @category Methods\r\n     */\r\n    addEventListener(type, listener) {\r\n        super.addEventListener(type, listener);\r\n    }\r\n    /**\r\n     * Removes the specified event listener\r\n     * e.g.\r\n     * ```\r\n     * cameraControl.addEventListener( 'controlstart', myCallbackFunction );\r\n     * ```\r\n     * @param type event name\r\n     * @param listener handler function\r\n     * @category Methods\r\n     */\r\n    removeEventListener(type, listener) {\r\n        super.removeEventListener(type, listener);\r\n    }\r\n    /**\r\n     * Rotate azimuthal angle(horizontal) and polar angle(vertical).\r\n     * Every value is added to the current value.\r\n     * @param azimuthAngle Azimuth rotate angle. In radian.\r\n     * @param polarAngle Polar rotate angle. In radian.\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    rotate(azimuthAngle, polarAngle, enableTransition = false) {\r\n        return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);\r\n    }\r\n    /**\r\n     * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.\r\n     *\r\n     * e.g.\r\n     * ```\r\n     * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );\r\n     * ```\r\n     * @param azimuthAngle Azimuth rotate angle. In radian.\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    rotateAzimuthTo(azimuthAngle, enableTransition = false) {\r\n        return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);\r\n    }\r\n    /**\r\n     * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.\r\n     *\r\n     * e.g.\r\n     * ```\r\n     * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );\r\n     * ```\r\n     * @param polarAngle Polar rotate angle. In radian.\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    rotatePolarTo(polarAngle, enableTransition = false) {\r\n        return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);\r\n    }\r\n    /**\r\n     * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.\r\n     * Camera view will rotate over the orbit pivot absolutely:\r\n     *\r\n     * azimuthAngle\r\n     * ```\r\n     *       0\u00BA\r\n     *         \\\r\n     * 90\u00BA -----+----- -90\u00BA\r\n     *           \\\r\n     *           180\u00BA\r\n     * ```\r\n     * | direction | angle                  |\r\n     * | --------- | ---------------------- |\r\n     * | front     | 0\u00BA                     |\r\n     * | left      | 90\u00BA (`Math.PI / 2`)    |\r\n     * | right     | -90\u00BA (`- Math.PI / 2`) |\r\n     * | back      | 180\u00BA (`Math.PI`)       |\r\n     *\r\n     * polarAngle\r\n     * ```\r\n     *     180\u00BA\r\n     *      |\r\n     *      90\u00BA\r\n     *      |\r\n     *      0\u00BA\r\n     * ```\r\n     * | direction            | angle                  |\r\n     * | -------------------- | ---------------------- |\r\n     * | top/sky              | 180\u00BA (`Math.PI`)       |\r\n     * | horizontal from view | 90\u00BA (`Math.PI / 2`)    |\r\n     * | bottom/floor         | 0\u00BA                     |\r\n     *\r\n     * @param azimuthAngle Azimuth rotate angle to. In radian.\r\n     * @param polarAngle Polar rotate angle to. In radian.\r\n     * @param enableTransition  Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    rotateTo(azimuthAngle, polarAngle, enableTransition = false) {\r\n        const theta = THREE.MathUtils.clamp(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);\r\n        const phi = THREE.MathUtils.clamp(polarAngle, this.minPolarAngle, this.maxPolarAngle);\r\n        this._sphericalEnd.theta = theta;\r\n        this._sphericalEnd.phi = phi;\r\n        this._sphericalEnd.makeSafe();\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._spherical.theta = this._sphericalEnd.theta;\r\n            this._spherical.phi = this._sphericalEnd.phi;\r\n        }\r\n        const resolveImmediately = !enableTransition ||\r\n            approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&\r\n                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * Dolly in/out camera position.\r\n     * @param distance Distance of dollyIn. Negative number for dollyOut.\r\n     * @param enableTransition Whether to move smoothly or immediately.\r\n     * @category Methods\r\n     */\r\n    dolly(distance, enableTransition = false) {\r\n        return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);\r\n    }\r\n    /**\r\n     * Dolly in/out camera position to given distance.\r\n     * @param distance Distance of dolly.\r\n     * @param enableTransition Whether to move smoothly or immediately.\r\n     * @category Methods\r\n     */\r\n    dollyTo(distance, enableTransition = false) {\r\n        const lastRadius = this._sphericalEnd.radius;\r\n        const newRadius = THREE.MathUtils.clamp(distance, this.minDistance, this.maxDistance);\r\n        const hasCollider = this.colliderMeshes.length >= 1;\r\n        if (hasCollider) {\r\n            const maxDistanceByCollisionTest = this._collisionTest();\r\n            const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);\r\n            const isDollyIn = lastRadius > newRadius;\r\n            if (!isDollyIn && isCollided)\r\n                return Promise.resolve();\r\n            this._sphericalEnd.radius = Math.min(newRadius, maxDistanceByCollisionTest);\r\n        }\r\n        else {\r\n            this._sphericalEnd.radius = newRadius;\r\n        }\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._spherical.radius = this._sphericalEnd.radius;\r\n        }\r\n        const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * Zoom in/out camera. The value is added to camera zoom.\r\n     * Limits set with `.minZoom` and `.maxZoom`\r\n     * @param zoomStep zoom scale\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    zoom(zoomStep, enableTransition = false) {\r\n        return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);\r\n    }\r\n    /**\r\n     * Zoom in/out camera to given scale. The value overwrites camera zoom.\r\n     * Limits set with .minZoom and .maxZoom\r\n     * @param zoom\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    zoomTo(zoom, enableTransition = false) {\r\n        this._zoomEnd = THREE.MathUtils.clamp(zoom, this.minZoom, this.maxZoom);\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._zoom = this._zoomEnd;\r\n        }\r\n        const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * @deprecated `pan()` has been renamed to `truck()`\r\n     * @category Methods\r\n     */\r\n    pan(x, y, enableTransition = false) {\r\n        console.warn('`pan` has been renamed to `truck`');\r\n        return this.truck(x, y, enableTransition);\r\n    }\r\n    /**\r\n     * Truck and pedestal camera using current azimuthal angle\r\n     * @param x Horizontal translate amount\r\n     * @param y Vertical translate amount\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    truck(x, y, enableTransition = false) {\r\n        this._camera.updateMatrix();\r\n        _xColumn.setFromMatrixColumn(this._camera.matrix, 0);\r\n        _yColumn.setFromMatrixColumn(this._camera.matrix, 1);\r\n        _xColumn.multiplyScalar(x);\r\n        _yColumn.multiplyScalar(-y);\r\n        const offset = _v3A.copy(_xColumn).add(_yColumn);\r\n        const to = _v3B.copy(this._targetEnd).add(offset);\r\n        return this.moveTo(to.x, to.y, to.z, enableTransition);\r\n    }\r\n    /**\r\n     * Move forward / backward.\r\n     * @param distance Amount to move forward / backward. Negative value to move backward\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    forward(distance, enableTransition = false) {\r\n        _v3A.setFromMatrixColumn(this._camera.matrix, 0);\r\n        _v3A.crossVectors(this._camera.up, _v3A);\r\n        _v3A.multiplyScalar(distance);\r\n        const to = _v3B.copy(this._targetEnd).add(_v3A);\r\n        return this.moveTo(to.x, to.y, to.z, enableTransition);\r\n    }\r\n    /**\r\n     * Move target position to given point.\r\n     * @param x x coord to move center position\r\n     * @param y y coord to move center position\r\n     * @param z z coord to move center position\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    moveTo(x, y, z, enableTransition = false) {\r\n        const offset = _v3A.set(x, y, z).sub(this._targetEnd);\r\n        this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._target.copy(this._targetEnd);\r\n        }\r\n        const resolveImmediately = !enableTransition ||\r\n            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&\r\n                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&\r\n                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.\r\n     *\r\n     * e.g.\r\n     * ```\r\n     * cameraControls.fitToBox( myMesh );\r\n     * ```\r\n     * @param box3OrObject Axis aligned bounding box to fit the view.\r\n     * @param enableTransition Whether to move smoothly or immediately.\r\n     * @param options | `<object>` { paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }\r\n     * @returns Transition end promise\r\n     * @category Methods\r\n     */\r\n    fitToBox(box3OrObject, enableTransition, { paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {\r\n        const promises = [];\r\n        const aabb = box3OrObject.isBox3\r\n            ? _box3A.copy(box3OrObject)\r\n            : _box3A.setFromObject(box3OrObject);\r\n        if (aabb.isEmpty()) {\r\n            console.warn('camera-controls: fitTo() cannot be used with an empty box. Aborting');\r\n            Promise.resolve();\r\n        }\r\n        // round to closest axis ( forward | backward | right | left | top | bottom )\r\n        const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);\r\n        const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);\r\n        promises.push(this.rotateTo(theta, phi, enableTransition));\r\n        const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();\r\n        const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);\r\n        const viewFromPolar = approxEquals(Math.abs(normal.y), 1);\r\n        if (viewFromPolar) {\r\n            rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));\r\n        }\r\n        // make oriented bounding box\r\n        const bb = _box3B.makeEmpty();\r\n        // left bottom back corner\r\n        _v3B.copy(aabb.min).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // right bottom back corner\r\n        _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // left top back corner\r\n        _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // right top back corner\r\n        _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // left bottom front corner\r\n        _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // right bottom front corner\r\n        _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // left top front corner\r\n        _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // right top front corner\r\n        _v3B.copy(aabb.max).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        rotation.setFromUnitVectors(_AXIS_Z, normal);\r\n        // add padding\r\n        bb.min.x -= paddingLeft;\r\n        bb.min.y -= paddingBottom;\r\n        bb.max.x += paddingRight;\r\n        bb.max.y += paddingTop;\r\n        const bbSize = bb.getSize(_v3A);\r\n        const center = bb.getCenter(_v3B).applyQuaternion(rotation);\r\n        if (isPerspectiveCamera(this._camera)) {\r\n            const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z);\r\n            promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));\r\n            promises.push(this.dollyTo(distance, enableTransition));\r\n            promises.push(this.setFocalOffset(0, 0, 0, enableTransition));\r\n        }\r\n        else if (isOrthographicCamera(this._camera)) {\r\n            const camera = this._camera;\r\n            const width = camera.right - camera.left;\r\n            const height = camera.top - camera.bottom;\r\n            const zoom = Math.min(width / bbSize.x, height / bbSize.y);\r\n            promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));\r\n            promises.push(this.zoomTo(zoom, enableTransition));\r\n            promises.push(this.setFocalOffset(0, 0, 0, enableTransition));\r\n        }\r\n        return Promise.all(promises);\r\n    }\r\n    /**\r\n     * Fit the viewport to the sphere or the bounding sphere of the object.\r\n     * @param sphereOrMesh\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    fitToSphere(sphereOrMesh, enableTransition) {\r\n        const promises = [];\r\n        const isSphere = sphereOrMesh instanceof THREE.Sphere;\r\n        const boundingSphere = isSphere ?\r\n            _sphere.copy(sphereOrMesh) :\r\n            createBoundingSphere(sphereOrMesh, _sphere);\r\n        promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));\r\n        if (isPerspectiveCamera(this._camera)) {\r\n            const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);\r\n            promises.push(this.dollyTo(distanceToFit, enableTransition));\r\n        }\r\n        else if (isOrthographicCamera(this._camera)) {\r\n            const width = this._camera.right - this._camera.left;\r\n            const height = this._camera.top - this._camera.bottom;\r\n            const diameter = 2 * boundingSphere.radius;\r\n            const zoom = Math.min(width / diameter, height / diameter);\r\n            promises.push(this.zoomTo(zoom, enableTransition));\r\n        }\r\n        promises.push(this.setFocalOffset(0, 0, 0, enableTransition));\r\n        return Promise.all(promises);\r\n    }\r\n    /**\r\n     * Make an orbit with given points.\r\n     * @param positionX\r\n     * @param positionY\r\n     * @param positionZ\r\n     * @param targetX\r\n     * @param targetY\r\n     * @param targetZ\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {\r\n        const target = _v3B.set(targetX, targetY, targetZ);\r\n        const position = _v3A.set(positionX, positionY, positionZ);\r\n        this._targetEnd.copy(target);\r\n        this._sphericalEnd.setFromVector3(position.sub(target).applyQuaternion(this._yAxisUpSpace));\r\n        this.normalizeRotations();\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._target.copy(this._targetEnd);\r\n            this._spherical.copy(this._sphericalEnd);\r\n        }\r\n        const resolveImmediately = !enableTransition ||\r\n            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&\r\n                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&\r\n                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) &&\r\n                approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&\r\n                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) &&\r\n                approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * Similar to setLookAt, but it interpolates between two states.\r\n     * @param positionAX\r\n     * @param positionAY\r\n     * @param positionAZ\r\n     * @param targetAX\r\n     * @param targetAY\r\n     * @param targetAZ\r\n     * @param positionBX\r\n     * @param positionBY\r\n     * @param positionBZ\r\n     * @param targetBX\r\n     * @param targetBY\r\n     * @param targetBZ\r\n     * @param t\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t, enableTransition = false) {\r\n        const targetA = _v3A.set(targetAX, targetAY, targetAZ);\r\n        const positionA = _v3B.set(positionAX, positionAY, positionAZ);\r\n        _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));\r\n        const targetB = _v3C.set(targetBX, targetBY, targetBZ);\r\n        const positionB = _v3B.set(positionBX, positionBY, positionBZ);\r\n        _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));\r\n        this._targetEnd.copy(targetA.lerp(targetB, t)); // tricky\r\n        const deltaTheta = _sphericalB.theta - _sphericalA.theta;\r\n        const deltaPhi = _sphericalB.phi - _sphericalA.phi;\r\n        const deltaRadius = _sphericalB.radius - _sphericalA.radius;\r\n        this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t, _sphericalA.phi + deltaPhi * t, _sphericalA.theta + deltaTheta * t);\r\n        this.normalizeRotations();\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._target.copy(this._targetEnd);\r\n            this._spherical.copy(this._sphericalEnd);\r\n        }\r\n        const resolveImmediately = !enableTransition ||\r\n            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&\r\n                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&\r\n                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) &&\r\n                approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&\r\n                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) &&\r\n                approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * setLookAt without target, keep gazing at the current target\r\n     * @param positionX\r\n     * @param positionY\r\n     * @param positionZ\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    setPosition(positionX, positionY, positionZ, enableTransition = false) {\r\n        return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);\r\n    }\r\n    /**\r\n     * setLookAt without position, Stay still at the position.\r\n     * @param targetX\r\n     * @param targetY\r\n     * @param targetZ\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    setTarget(targetX, targetY, targetZ, enableTransition = false) {\r\n        const pos = this.getPosition(_v3A);\r\n        return this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);\r\n    }\r\n    /**\r\n     * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.\r\n     * @param x\r\n     * @param y\r\n     * @param z\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    setFocalOffset(x, y, z, enableTransition = false) {\r\n        this._focalOffsetEnd.set(x, y, z);\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._focalOffset.copy(this._focalOffsetEnd);\r\n        }\r\n        const resolveImmediately = !enableTransition ||\r\n            approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) &&\r\n                approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) &&\r\n                approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * Set orbit point without moving the camera.\r\n     * @param targetX\r\n     * @param targetY\r\n     * @param targetZ\r\n     * @category Methods\r\n     */\r\n    setOrbitPoint(targetX, targetY, targetZ) {\r\n        _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);\r\n        _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);\r\n        _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);\r\n        const position = _v3A.set(targetX, targetY, targetZ);\r\n        const distance = position.distanceTo(this._camera.position);\r\n        const cameraToPoint = position.sub(this._camera.position);\r\n        _xColumn.multiplyScalar(cameraToPoint.x);\r\n        _yColumn.multiplyScalar(cameraToPoint.y);\r\n        _zColumn.multiplyScalar(cameraToPoint.z);\r\n        _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);\r\n        _v3A.z = _v3A.z + distance;\r\n        this.dollyTo(distance, false);\r\n        this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);\r\n        this.moveTo(targetX, targetY, targetZ, false);\r\n    }\r\n    /**\r\n     * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3\r\n     * @param box3\r\n     * @category Methods\r\n     */\r\n    setBoundary(box3) {\r\n        if (!box3) {\r\n            this._boundary.min.set(-Infinity, -Infinity, -Infinity);\r\n            this._boundary.max.set(Infinity, Infinity, Infinity);\r\n            this._needsUpdate = true;\r\n            return;\r\n        }\r\n        this._boundary.copy(box3);\r\n        this._boundary.clampPoint(this._targetEnd, this._targetEnd);\r\n        this._needsUpdate = true;\r\n    }\r\n    /**\r\n     * Set (or unset) the current viewport.\r\n     * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.\r\n     * @param viewportOrX\r\n     * @param y\r\n     * @param width\r\n     * @param height\r\n     * @category Methods\r\n     */\r\n    setViewport(viewportOrX, y, width, height) {\r\n        if (viewportOrX === null) { // null\r\n            this._viewport = null;\r\n            return;\r\n        }\r\n        this._viewport = this._viewport || new THREE.Vector4();\r\n        if (typeof viewportOrX === 'number') { // number\r\n            this._viewport.set(viewportOrX, y, width, height);\r\n        }\r\n        else { // Vector4\r\n            this._viewport.copy(viewportOrX);\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the distance to fit the box.\r\n     * @param width box width\r\n     * @param height box height\r\n     * @param depth box depth\r\n     * @returns distance\r\n     * @category Methods\r\n     */\r\n    getDistanceToFitBox(width, height, depth) {\r\n        if (notSupportedInOrthographicCamera(this._camera, 'getDistanceToFitBox'))\r\n            return this._spherical.radius;\r\n        const boundingRectAspect = width / height;\r\n        const fov = this._camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD;\r\n        const aspect = this._camera.aspect;\r\n        const heightToFit = boundingRectAspect < aspect ? height : width / aspect;\r\n        return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;\r\n    }\r\n    /**\r\n     * Calculate the distance to fit the sphere.\r\n     * @param radius sphere radius\r\n     * @returns distance\r\n     * @category Methods\r\n     */\r\n    getDistanceToFitSphere(radius) {\r\n        if (notSupportedInOrthographicCamera(this._camera, 'getDistanceToFitSphere'))\r\n            return this._spherical.radius;\r\n        // https://stackoverflow.com/a/44849975\r\n        const vFOV = this._camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD;\r\n        const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;\r\n        const fov = 1 < this._camera.aspect ? vFOV : hFOV;\r\n        return radius / (Math.sin(fov * 0.5));\r\n    }\r\n    /**\r\n     * Returns its current gazing target, which is the center position of the orbit.\r\n     * @param out current gazing target\r\n     * @category Methods\r\n     */\r\n    getTarget(out) {\r\n        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();\r\n        return _out.copy(this._targetEnd);\r\n    }\r\n    /**\r\n     * Returns its current position.\r\n     * @param out current position\r\n     * @category Methods\r\n     */\r\n    getPosition(out) {\r\n        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();\r\n        return _out.setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).add(this._targetEnd);\r\n    }\r\n    /**\r\n     * Returns its current focal offset, which is how much the camera appears to be translated in screen parallel coordinates.\r\n     * @param out current focal offset\r\n     * @category Methods\r\n     */\r\n    getFocalOffset(out) {\r\n        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();\r\n        return _out.copy(this._focalOffsetEnd);\r\n    }\r\n    /**\r\n     * Normalize camera azimuth angle rotation between 0 and 360 degrees.\r\n     * @category Methods\r\n     */\r\n    normalizeRotations() {\r\n        this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;\r\n        if (this._sphericalEnd.theta < 0)\r\n            this._sphericalEnd.theta += PI_2;\r\n        this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);\r\n    }\r\n    /**\r\n     * Reset all rotation and position to defaults.\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    reset(enableTransition = false) {\r\n        const promises = [\r\n            this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),\r\n            this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),\r\n            this.zoomTo(this._zoom0, enableTransition),\r\n        ];\r\n        return Promise.all(promises);\r\n    }\r\n    /**\r\n     * Set current camera position as the default position.\r\n     * @category Methods\r\n     */\r\n    saveState() {\r\n        this._target0.copy(this._target);\r\n        this._position0.copy(this._camera.position);\r\n        this._zoom0 = this._zoom;\r\n    }\r\n    /**\r\n     * Sync camera-up direction.\r\n     * When camera-up vector is changed, `.updateCameraUp()` must be called.\r\n     * @category Methods\r\n     */\r\n    updateCameraUp() {\r\n        this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);\r\n        quatInvertCompat(this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace));\r\n    }\r\n    /**\r\n     * Update camera position and directions.\r\n     * This should be called in your tick loop every time, and returns true if re-rendering is needed.\r\n     * @param delta\r\n     * @returns updated\r\n     * @category Methods\r\n     */\r\n    update(delta) {\r\n        const dampingFactor = this._state === ACTION.NONE ? this.dampingFactor : this.draggingDampingFactor;\r\n        // The original THREE.OrbitControls assume 60 FPS fixed and does NOT rely on delta time.\r\n        // (that must be a problem of the original one though)\r\n        // To to emulate the speed of the original one under 60 FPS, multiply `60` to delta,\r\n        // but ours are more flexible to any FPS unlike the original.\r\n        const lerpRatio = Math.min(dampingFactor * delta * 60, 1);\r\n        const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;\r\n        const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;\r\n        const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;\r\n        const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);\r\n        const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);\r\n        if (!approxZero(deltaTheta) ||\r\n            !approxZero(deltaPhi) ||\r\n            !approxZero(deltaRadius) ||\r\n            !approxZero(deltaTarget.x) ||\r\n            !approxZero(deltaTarget.y) ||\r\n            !approxZero(deltaTarget.z) ||\r\n            !approxZero(deltaOffset.x) ||\r\n            !approxZero(deltaOffset.y) ||\r\n            !approxZero(deltaOffset.z)) {\r\n            this._spherical.set(this._spherical.radius + deltaRadius * lerpRatio, this._spherical.phi + deltaPhi * lerpRatio, this._spherical.theta + deltaTheta * lerpRatio);\r\n            this._target.add(deltaTarget.multiplyScalar(lerpRatio));\r\n            this._focalOffset.add(deltaOffset.multiplyScalar(lerpRatio));\r\n            this._needsUpdate = true;\r\n        }\r\n        else {\r\n            this._spherical.copy(this._sphericalEnd);\r\n            this._target.copy(this._targetEnd);\r\n            this._focalOffset.copy(this._focalOffsetEnd);\r\n        }\r\n        if (this._dollyControlAmount !== 0) {\r\n            if (isPerspectiveCamera(this._camera)) {\r\n                const camera = this._camera;\r\n                const direction = _v3A.setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate();\r\n                const planeX = _v3B.copy(direction).cross(camera.up).normalize();\r\n                if (planeX.lengthSq() === 0)\r\n                    planeX.x = 1.0;\r\n                const planeY = _v3C.crossVectors(planeX, direction);\r\n                const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD * 0.5);\r\n                const prevRadius = this._sphericalEnd.radius - this._dollyControlAmount;\r\n                const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;\r\n                const cursor = _v3A.copy(this._targetEnd)\r\n                    .add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect))\r\n                    .add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));\r\n                this._targetEnd.lerp(cursor, lerpRatio);\r\n                this._target.copy(this._targetEnd);\r\n            }\r\n            else if (isOrthographicCamera(this._camera)) {\r\n                const camera = this._camera;\r\n                const worldPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);\r\n                const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);\r\n                const divisor = quaternion.dot(camera.up);\r\n                const distance = approxZero(divisor) ? -worldPosition.dot(camera.up) : -worldPosition.dot(camera.up) / divisor;\r\n                const cursor = _v3C.copy(worldPosition).add(quaternion.multiplyScalar(distance));\r\n                this._targetEnd.lerp(cursor, 1 - camera.zoom / this._dollyControlAmount);\r\n                this._target.copy(this._targetEnd);\r\n            }\r\n            this._dollyControlAmount = 0;\r\n        }\r\n        const maxDistance = this._collisionTest();\r\n        this._spherical.radius = Math.min(this._spherical.radius, maxDistance);\r\n        // decompose spherical to the camera position\r\n        this._spherical.makeSafe();\r\n        this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);\r\n        this._camera.lookAt(this._target);\r\n        // set offset after the orbit movement\r\n        const affectOffset = !approxZero(this._focalOffset.x) ||\r\n            !approxZero(this._focalOffset.y) ||\r\n            !approxZero(this._focalOffset.z);\r\n        if (affectOffset) {\r\n            this._camera.updateMatrix();\r\n            _xColumn.setFromMatrixColumn(this._camera.matrix, 0);\r\n            _yColumn.setFromMatrixColumn(this._camera.matrix, 1);\r\n            _zColumn.setFromMatrixColumn(this._camera.matrix, 2);\r\n            _xColumn.multiplyScalar(this._focalOffset.x);\r\n            _yColumn.multiplyScalar(-this._focalOffset.y);\r\n            _zColumn.multiplyScalar(this._focalOffset.z); // notice: z-offset will not affect in Orthographic.\r\n            _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);\r\n            this._camera.position.add(_v3A);\r\n        }\r\n        if (this._boundaryEnclosesCamera) {\r\n            this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1.0);\r\n        }\r\n        // zoom\r\n        const zoomDelta = this._zoomEnd - this._zoom;\r\n        this._zoom += zoomDelta * lerpRatio;\r\n        if (this._camera.zoom !== this._zoom) {\r\n            if (approxZero(zoomDelta))\r\n                this._zoom = this._zoomEnd;\r\n            this._camera.zoom = this._zoom;\r\n            this._camera.updateProjectionMatrix();\r\n            this._updateNearPlaneCorners();\r\n            this._needsUpdate = true;\r\n        }\r\n        const updated = this._needsUpdate;\r\n        if (updated && !this._updatedLastTime) {\r\n            this._hasRested = false;\r\n            this.dispatchEvent({ type: 'wake' });\r\n            this.dispatchEvent({ type: 'update' });\r\n        }\r\n        else if (updated) {\r\n            this.dispatchEvent({ type: 'update' });\r\n            if (approxZero(deltaTheta, this.restThreshold) &&\r\n                approxZero(deltaPhi, this.restThreshold) &&\r\n                approxZero(deltaRadius, this.restThreshold) &&\r\n                approxZero(deltaTarget.x, this.restThreshold) &&\r\n                approxZero(deltaTarget.y, this.restThreshold) &&\r\n                approxZero(deltaTarget.z, this.restThreshold) &&\r\n                approxZero(deltaOffset.x, this.restThreshold) &&\r\n                approxZero(deltaOffset.y, this.restThreshold) &&\r\n                approxZero(deltaOffset.z, this.restThreshold) &&\r\n                !this._hasRested) {\r\n                this._hasRested = true;\r\n                this.dispatchEvent({ type: 'rest' });\r\n            }\r\n        }\r\n        else if (!updated && this._updatedLastTime) {\r\n            this.dispatchEvent({ type: 'sleep' });\r\n        }\r\n        this._updatedLastTime = updated;\r\n        this._needsUpdate = false;\r\n        return updated;\r\n    }\r\n    /**\r\n     * Get all state in JSON string\r\n     * @category Methods\r\n     */\r\n    toJSON() {\r\n        return JSON.stringify({\r\n            enabled: this._enabled,\r\n            minDistance: this.minDistance,\r\n            maxDistance: infinityToMaxNumber(this.maxDistance),\r\n            minZoom: this.minZoom,\r\n            maxZoom: infinityToMaxNumber(this.maxZoom),\r\n            minPolarAngle: this.minPolarAngle,\r\n            maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),\r\n            minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),\r\n            maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),\r\n            dampingFactor: this.dampingFactor,\r\n            draggingDampingFactor: this.draggingDampingFactor,\r\n            dollySpeed: this.dollySpeed,\r\n            truckSpeed: this.truckSpeed,\r\n            dollyToCursor: this.dollyToCursor,\r\n            verticalDragToForward: this.verticalDragToForward,\r\n            target: this._targetEnd.toArray(),\r\n            position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),\r\n            zoom: this._zoomEnd,\r\n            focalOffset: this._focalOffsetEnd.toArray(),\r\n            target0: this._target0.toArray(),\r\n            position0: this._position0.toArray(),\r\n            zoom0: this._zoom0,\r\n            focalOffset0: this._focalOffset0.toArray(),\r\n        });\r\n    }\r\n    /**\r\n     * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.\r\n     * @param json\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    fromJSON(json, enableTransition = false) {\r\n        const obj = JSON.parse(json);\r\n        const position = _v3A.fromArray(obj.position);\r\n        this.enabled = obj.enabled;\r\n        this.minDistance = obj.minDistance;\r\n        this.maxDistance = maxNumberToInfinity(obj.maxDistance);\r\n        this.minZoom = obj.minZoom;\r\n        this.maxZoom = maxNumberToInfinity(obj.maxZoom);\r\n        this.minPolarAngle = obj.minPolarAngle;\r\n        this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);\r\n        this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);\r\n        this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);\r\n        this.dampingFactor = obj.dampingFactor;\r\n        this.draggingDampingFactor = obj.draggingDampingFactor;\r\n        this.dollySpeed = obj.dollySpeed;\r\n        this.truckSpeed = obj.truckSpeed;\r\n        this.dollyToCursor = obj.dollyToCursor;\r\n        this.verticalDragToForward = obj.verticalDragToForward;\r\n        this._target0.fromArray(obj.target0);\r\n        this._position0.fromArray(obj.position0);\r\n        this._zoom0 = obj.zoom0;\r\n        this._focalOffset0.fromArray(obj.focalOffset0);\r\n        this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);\r\n        _sphericalA.setFromVector3(position.sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));\r\n        this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);\r\n        this.zoomTo(obj.zoom, enableTransition);\r\n        this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);\r\n        this._needsUpdate = true;\r\n    }\r\n    /**\r\n     * Dispose the cameraControls instance itself, remove all eventListeners.\r\n     * @category Methods\r\n     */\r\n    dispose() {\r\n        this._removeAllEventListeners();\r\n    }\r\n    _findPointerById(pointerId) {\r\n        // to support IE11 use some instead of Array#find (will be removed when IE11 is deprecated)\r\n        let pointer = null;\r\n        this._activePointers.some((activePointer) => {\r\n            if (activePointer.pointerId === pointerId) {\r\n                pointer = activePointer;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return pointer;\r\n    }\r\n    _encloseToBoundary(position, offset, friction) {\r\n        const offsetLength2 = offset.lengthSq();\r\n        if (offsetLength2 === 0.0) { // sanity check\r\n            return position;\r\n        }\r\n        // See: https://twitter.com/FMS_Cat/status/1106508958640988161\r\n        const newTarget = _v3B.copy(offset).add(position); // target\r\n        const clampedTarget = this._boundary.clampPoint(newTarget, _v3C); // clamped target\r\n        const deltaClampedTarget = clampedTarget.sub(newTarget); // newTarget -> clampedTarget\r\n        const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq(); // squared length of deltaClampedTarget\r\n        if (deltaClampedTargetLength2 === 0.0) { // when the position doesn't have to be clamped\r\n            return position.add(offset);\r\n        }\r\n        else if (deltaClampedTargetLength2 === offsetLength2) { // when the position is completely stuck\r\n            return position;\r\n        }\r\n        else if (friction === 0.0) {\r\n            return position.add(offset).add(deltaClampedTarget);\r\n        }\r\n        else {\r\n            const offsetFactor = 1.0 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);\r\n            return position\r\n                .add(_v3B.copy(offset).multiplyScalar(offsetFactor))\r\n                .add(deltaClampedTarget.multiplyScalar(1.0 - friction));\r\n        }\r\n    }\r\n    _updateNearPlaneCorners() {\r\n        if (isPerspectiveCamera(this._camera)) {\r\n            const camera = this._camera;\r\n            const near = camera.near;\r\n            const fov = camera.getEffectiveFOV() * THREE.MathUtils.DEG2RAD;\r\n            const heightHalf = Math.tan(fov * 0.5) * near; // near plain half height\r\n            const widthHalf = heightHalf * camera.aspect; // near plain half width\r\n            this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);\r\n            this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);\r\n            this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);\r\n            this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);\r\n        }\r\n        else if (isOrthographicCamera(this._camera)) {\r\n            const camera = this._camera;\r\n            const zoomInv = 1 / camera.zoom;\r\n            const left = camera.left * zoomInv;\r\n            const right = camera.right * zoomInv;\r\n            const top = camera.top * zoomInv;\r\n            const bottom = camera.bottom * zoomInv;\r\n            this._nearPlaneCorners[0].set(left, top, 0);\r\n            this._nearPlaneCorners[1].set(right, top, 0);\r\n            this._nearPlaneCorners[2].set(right, bottom, 0);\r\n            this._nearPlaneCorners[3].set(left, bottom, 0);\r\n        }\r\n    }\r\n    // lateUpdate\r\n    _collisionTest() {\r\n        let distance = Infinity;\r\n        const hasCollider = this.colliderMeshes.length >= 1;\r\n        if (!hasCollider)\r\n            return distance;\r\n        if (notSupportedInOrthographicCamera(this._camera, '_collisionTest'))\r\n            return distance;\r\n        // divide by distance to normalize, lighter than `Vector3.prototype.normalize()`\r\n        const direction = _v3A.setFromSpherical(this._spherical).divideScalar(this._spherical.radius);\r\n        _rotationMatrix.lookAt(_ORIGIN, direction, this._camera.up);\r\n        for (let i = 0; i < 4; i++) {\r\n            const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i]);\r\n            nearPlaneCorner.applyMatrix4(_rotationMatrix);\r\n            const origin = _v3C.addVectors(this._target, nearPlaneCorner);\r\n            _raycaster.set(origin, direction);\r\n            _raycaster.far = this._spherical.radius + 1;\r\n            const intersects = _raycaster.intersectObjects(this.colliderMeshes);\r\n            if (intersects.length !== 0 && intersects[0].distance < distance) {\r\n                distance = intersects[0].distance;\r\n            }\r\n        }\r\n        return distance;\r\n    }\r\n    /**\r\n     * Get its client rect and package into given `DOMRect` .\r\n     */\r\n    _getClientRect(target) {\r\n        const rect = this._domElement.getBoundingClientRect();\r\n        target.x = rect.left;\r\n        target.y = rect.top;\r\n        if (this._viewport) {\r\n            target.x += this._viewport.x;\r\n            target.y += rect.height - this._viewport.w - this._viewport.y;\r\n            target.width = this._viewport.z;\r\n            target.height = this._viewport.w;\r\n        }\r\n        else {\r\n            target.width = rect.width;\r\n            target.height = rect.height;\r\n        }\r\n        return target;\r\n    }\r\n    _createOnRestPromise(resolveImmediately) {\r\n        if (resolveImmediately)\r\n            return Promise.resolve();\r\n        this._hasRested = false;\r\n        this.dispatchEvent({ type: 'transitionstart' });\r\n        return new Promise((resolve) => {\r\n            const onResolve = () => {\r\n                this.removeEventListener('rest', onResolve);\r\n                resolve();\r\n            };\r\n            this.addEventListener('rest', onResolve);\r\n        });\r\n    }\r\n    _removeAllEventListeners() { }\r\n}\r\nfunction createBoundingSphere(object3d, out) {\r\n    const boundingSphere = out;\r\n    const center = boundingSphere.center;\r\n    _box3A.makeEmpty();\r\n    // find the center\r\n    object3d.traverseVisible((object) => {\r\n        if (!object.isMesh)\r\n            return;\r\n        _box3A.expandByObject(object);\r\n    });\r\n    _box3A.getCenter(center);\r\n    // find the radius\r\n    let maxRadiusSq = 0;\r\n    object3d.traverseVisible((object) => {\r\n        if (!object.isMesh)\r\n            return;\r\n        const mesh = object;\r\n        const geometry = mesh.geometry.clone();\r\n        geometry.applyMatrix4(mesh.matrixWorld);\r\n        if (geometry.isBufferGeometry) {\r\n            const bufferGeometry = geometry;\r\n            const position = bufferGeometry.attributes.position;\r\n            for (let i = 0, l = position.count; i < l; i++) {\r\n                _v3A.fromBufferAttribute(position, i);\r\n                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));\r\n            }\r\n        }\r\n        else {\r\n            // for old three.js, which supports both BufferGeometry and Geometry\r\n            // this condition block will be removed in the near future.\r\n            const position = geometry.attributes.position;\r\n            const vector = new THREE.Vector3();\r\n            for (let i = 0, l = position.count; i < l; i++) {\r\n                vector.fromBufferAttribute(position, i);\r\n                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\r\n            }\r\n        }\r\n    });\r\n    boundingSphere.radius = Math.sqrt(maxRadiusSq);\r\n    return boundingSphere;\r\n}\n\nexport { CameraControls as default };\n", "import d from \"./node_modules/camera-controls/dist/camera-controls.module.js\";export default d;"],
  "mappings": "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",
  "names": []
}
